/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package gr.demokritos.iit.utilities.utils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * This class contains general tools for the whole platform
 *
 * @author Panagiotis Giotis <giotis.p@gmail.com>
 */
public class Utilities {

    private static HashMap<Integer, String> codeMessageMap = new HashMap<>();

    /**
     * Utilities constructor
     */
    public Utilities() {
        codeMessageMap.put(100, "Process complete");
        codeMessageMap.put(200, "Error 1");
        codeMessageMap.put(300, "Error 2");
        codeMessageMap.put(400, "Error 3");
    }

    /**
     * Get Message based on given code
     *
     * @param code The error code number
     * @return The current error message
     */
    public static String getMessageCode(Integer code) {
        return codeMessageMap.get(code);
    }

    /**
     * Generate a UUID from given text
     *
     * @param text A text for the UUID
     * @return A UUID generated by the combination of given text and current
     * timestamp
     */
    public static UUID getUUID(String text) {
        Date time = new Date();
        String uid = text + "-" + time.getTime();

        return UUID.nameUUIDFromBytes(uid.getBytes());
    }

    /**
     * Short a Map with Double values
     *
     * @param passedMap The unsorted map
     * @param reverseOrder The flag for reverse Order
     * @return The shorted map
     */
    public LinkedHashMap<String, Double> sortMapByDoubleValues(Map<String, Double> passedMap,
            boolean reverseOrder) {
        List mapKeys = new ArrayList(passedMap.keySet());
        List mapValues = new ArrayList(passedMap.values());
        if (reverseOrder) {
            Collections.sort(mapValues, Collections.reverseOrder());
            Collections.sort(mapKeys, Collections.reverseOrder());
        } else {
            Collections.sort(mapValues);
            Collections.sort(mapKeys);
        }

        LinkedHashMap<String, Double> sortedMap = new LinkedHashMap();

        Iterator valueIt = mapValues.iterator();
        while (valueIt.hasNext()) {
            Object val = valueIt.next();
            Iterator keyIt = mapKeys.iterator();

            while (keyIt.hasNext()) {
                Object key = keyIt.next();
                String comp1 = passedMap.get(key).toString();
                String comp2 = val.toString();

                if (comp1.equals(comp2)) {
                    passedMap.remove(key);
                    mapKeys.remove(key);
                    sortedMap.put((String) key, (Double) val);
                    break;
                }
            }
        }
        return sortedMap;
    }

    /**
     * Convert Map<String,String> to Map<String,Integer>
     *
     * @param map
     * @return
     */
    public Map<String, Integer> mapValueStringToInteger(Map<String, String> map) {
        HashMap<String, Integer> returnMap = new HashMap<>();

        for (String cKey : map.keySet()) {
            returnMap.put(cKey, Integer.parseInt(map.get(cKey)));
        }

        return returnMap;
    }

    /**
     * Convert Map<String,Integer> to Map<String,String>
     *
     * @param map
     * @return
     */
    public Map<String, String> mapValueIntegerToString(Map<String, Integer> map) {
        HashMap<String, String> returnMap = new HashMap<>();

        for (String cKey : map.keySet()) {
            returnMap.put(cKey, map.get(cKey).toString());
        }

        return returnMap;
    }

}
